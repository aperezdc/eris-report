% vim: ft=tex spell spelllang=en ts=2 sw=2

\chapter{Introduction}

\section{Description \& Motivation}

Most programming languages provide some mechanism to use libraries —sometimes
called \emph{modules}— implemented in some other language. Most of the time,
this other language belongs to the members of the “C family” which can be
compiled into \emph{native object code}. The reasons are twofold: this allows
to reuse functionality provided by the system that otherwise would not be
available, and in the other hand it opens the possibility of implementing
performance--critical pieces of a system using native code.

Despite the advantages, using native code from a dynamic programming language
requires creating a layer of software often called \emph{bridge}, or
\emph{binding} from now on, which wraps the native library to provide an
interface compatible with the run-time environment of the dynamic programming
language. Those bindings, created either manually or with the help of code
generation tools, need to be compiled before they can be used.

However, when building native code, compilers are capable of adding
\emph{debugging information} to their output, which can be used to gain
additional insight into a program using a \emph{symbolic debugger}. As
a matter of fact, any other tool capable of understanding the format in which
the compiler writes the debugging information can make use of it for its own
purposes. Among plenty other details about the source program, debugging
information includes descriptions of the function compiled as part of each
compilation unit, parameters and their corresponding data types, the return
type, and the memory layout of the involved user-defined types; which is a
superset of the information needed to invoke those functions. The debugging
information contains all the details needed to make library bindings
automatically, potentially allowing dynamic programming languages to invoke
native code directly without any kind of human intervention.

% The goal of this project is to implement such an automatic invocation method
% for the Lua programming language, using the debugging information in \Dwarf*
% format as generated by the compiler to allow calling into native code from
% arbitrary libraries at run-time, without needing the presence of previously
% created bindings.


\section{Project Goals}

The main goal of this project is developing an automatic binding system for
the Lua programming language which allows seamless usage of libraries written
in C at runtime. To achieve this, it will use the debugging information
generated by the C compiler. In particular:

\begin{itemize}
	\item Modifications to the Lua virtual machine, or its core libraries is
		to be avoided, if possible.
	\item The implementation will be able to load \gls{ELF} shared objects
		into the Lua virtual machine, and use the debugging information in
		\gls{DWARF} format present in them.
	\item Values of C types, including user defined ones, should be readable
		and modifiable from Lua. It will also be possible to create new
		values of C types from Lua.
	\item Invocation of functions from loaded shared objects will work for
		function of arbitrary return types, for functions of any number of
		parameters of any supported type. Lua values passed to functions
		will be automatically converted to C types whenever possible. Values
		of C types created from Lua will also be accepted as valid function
		parameters.
	\item The implementation will target the GNU/Linux operating system
		running on the x86\_64 architecture,
	\item The design of the system should be extensible, allowing to add
		support for more shared object formats, debugging information formats,
		operating systems, and architectures.
\end{itemize}


\section{Planning \& Methodologies}

During the planification phase, the following tasks and subtasks have been
identified:

\begin{itemize}
	\item Initial study, including:
		\begin{itemize}
			\item Understanding how different kinds of data are stored in \gls{ELF}
				object files.
			\item Identifying the parts of the \gls{DWARF} specification which apply
				to the scope of the project.
			\item Investigation of existing tools which share similar goals.
		\end{itemize}

	\item Analysis, including:
		\begin{itemize}
			\item Understanding the relevant parts of the \gls{DWARF}
				debugging information format.
			\item Getting acquainted with Lua and the implementation
				of its \gls{VM}.
		\end{itemize}

	\item Setting-up the work environment and getting acquainted with the tools
		used during the development of the system.

	\item Design of the automatic binding system.

	\item Implement the automatic binding mechanism.

	\item Test and validate the system, including:
		\begin{itemize}
			\item Investigate existing unit testing frameworks with Lua support and
				determine whether they are usable in the context of this project.
			\item Design a set of unit and regressions tests.
			\item Implement the unit and regression tests.
		\end{itemize}

	\item Develop example Lua programs which demonstrate the capabilities of
		the system, and will serve to validate the system with real-world
		programs.

	\item Writing of the final report.
	% \item Determine whether to use an existing JIT code generator or to
	% 	implement our own.
	% \item Design the JIT code generator.
	% \item Implement the JIT code generator.
\end{itemize}


For each one of the top-level tasks in the list above,
\autoref{tab:effort-estimate} provides an estimation of the time needed for
the completion, using an effort of eight hours per person, per day (8h/p/d).

\begin{table}
	\centering
	\begin{tabular}{lr}
		\toprule
		Task & Estimation (days) \\
		\midrule
		Initial study     &  5 \\
		Analysis          & 15 \\
		Environment setup &  3 \\
		Design            &  4 \\
		Implementation    & 30 \\
		Testing           & 10 \\
		Example programs  &  2 \\
		Final report      & 15 \\
		\midrule
		\emph{Total}      & 84 \\
		\bottomrule
	\end{tabular}
	\caption{Effort estimation}
	\label{tab:effort-estimate}
\end{table}

Even though there is only one resource executing the tasks, some techniques
from agile development methodologies are used. Namely:

\begin{itemize}
	\item From Scrum, the concepts of \emph{iteration} and \emph{sprints}, with
    their respective planning and review seasons. Daily stand-up meeting are
    not used, and there is no \emph{scrum master}: none of those would make
    make sense provided that there is only one person in the team.
  \item The \emph{Kanban} methodology is used in order to keep an always
		up to date dashboard with the status of the tasks.
\end{itemize}

The Kanban method was invented by \gls{Toyota} to keep the status of
productions lines, keeps a board (physical, in the original incarnation of the
method) where each element is a task, and elements are distributed in columns
depending on their status. For example, applied to software development, the
columns could be “Pending”, “In Progress”, “Testing”, and “Finished”. All the
tasks are always visible in the board, so this allows to know the overall
status of a project intuitively by glancing at the board.
