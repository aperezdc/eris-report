% vim: ft=tex spell spelllang=en

\chapter{Introduction}

\section{Description \& Motivation}

Most programming languages provide some mechanism to use libraries —sometimes
called \emph{modules}— implemented in some other language. Most of the time,
this other language belongs to the members of the “C family” which can be
compiled into \emph{native object code}. The reasons are twofold: this allows
to reuse functionality provided by the system that otherwise would not be
available, and in the other hand it opens the possibility of implementing
performance--critical pieces of a system using native code.

Despite the advantages, using native code from a dynamic programming language
requires creating a layer of software often called \emph{bridge}, or
\emph{binding} from now on, which wraps the native library to provide an
interface compatible with the run-time environment of the dynamic programming
language. Those bindings, created either manually or with the help of code
generation tools, need to be compiled before they can be used.

However, when building native code, compilers are capable of adding
\emph{debugging information} to their output, which can be used to gain
additional insight into a program using a \emph{symbolic debugger}. As
a matter of fact, any other tool capable of understanding the format in which
the compiler writes the debugging information can make use of it for its own
purposes. Among plenty other details about the source program, debugging
information includes descriptions of the function compiled as part of each
compilation unit, parameters and their corresponding data types, the return
type, and the memory layout of the involved user-defined types; which is a
superset of the information needed to invoke those functions. The debugging
information contains all the details needed to make library bindings
automatically, potentially allowing dynamic programming languages to invoke
native code directly without any kind of human intervention.

% The goal of this project is to implement such an automatic invocation method
% for the Lua programming language, using the debugging information in \Dwarf*
% format as generated by the compiler to allow calling into native code from
% arbitrary libraries at run-time, without needing the presence of previously
% created bindings.


\section{Project Goals}

The main goal of this project is developing an automatic binding system for
the Lua programming language which allows seamless usage of libraries written
in C at runtime. To achieve this, it will use the debugging information
generated by the C compiler. In particular:

\begin{itemize}
	\item Modifications to the Lua virtual machine, or its core libraries is
		to be avoided, if possible.
	\item The implementation will be able to load \gls{ELF} shared objects
		into the Lua virtual machine, and use the debugging information in
		\gls{DWARF} format present in them.
	\item Values of C types, including user defined ones, should be readable
		and modifiable from Lua. It will also be possible to create new
		values of C types from Lua.
	\item Invocation of functions from loaded shared objects will work for
		function of arbitrary return types, for functions of any number of
		parameters of any supported type. Lua values passed to functions
		will be automatically converted to C types whenever possible. Values
		of C types created from Lua will also be accepted as valid function
		parameters.
	\item The implementation will target the GNU/Linux operating system
		running on the x86\_64 architecture,
	\item The design of the system should be extensible, allowing to add
		support for more shared object formats, debugging information formats,
		operating systems, and architectures.
\end{itemize}


\section{Planning \& Methodologies}

The following are the main tasks identified:

\begin{itemize}
	\item Getting acquainted with Lua.
	\item Reading and understanding the \gls{DWARF} Specification.
	\item Design of the automatic binding procedure.
	\item Implement the automatic binding mechanism.
	\item Determine whether to use an existing JIT code generator or to
		implement our own.
	\item Design the JIT code generator.
	\item Implement the JIT code generator.
\end{itemize}
