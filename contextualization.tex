% vim: ft=tex spell spelllang=en ts=2 sw=2

\chapter{Contextualization}
% TODO: \minitoc ?

Computing would not be understood without the accompanying tools which enable
IT professionals to actually \emph{do something} with computers: from simple
switches and lights in the early times, to the sophisticated programming
languages and tools of the present times, all of them enable humans to
\emph{instruct machines to do things}.

%% TODO

\section{Dynamic Programming Languages}

Dynamic languages \todo{Add bibliographic reference} are a family of
high-level programming languages which, at runtime, execute programming
behaviors that other programming languages perform during compilation. Runtime
behaviors could include extension of the program, by adding new code, by
extending objects and definitions, or by modifying the type system. Support
for these operations is provided directly by the language. Most dynamic
languages are also dynamically typed, and are frequently called “scripting
languages”.

Popular contemporary scripting languages include Perl, Python, PHP, the
ubiquitous JavaScript, and of course Lua (described in
\autoref{sec:lua-programming-lang}). Many of their features were first
implemented as native features of the Lisp programming language, which itself
is dynamic.

Dynamic programming languages have grown in popularity in the last decades.
Programmers like them for their expressiveness, which allows for higher
productivity, and the ever increasing computing power of computers makes it
feasible to use them for performance-critical tasks traditionally left for
statically compiled languages. The development of novel compilation techniques
aimed at this family of languages, and the relentless improvement of their
virtual machines (see \autoref{sec:virtual-machines}), has contributed as well
to increase widespread adoption.

\subsection{Virtual Machines as Runtime Environments}
  \label{sec:virtual-machines}

A \gls{VM} is an \gls{emulation} of a particular computer system based on its
architecture. \emph{System virtual machines} provide a complete substitute for
the real machine, and targeted towards the execution of complete operating
systems and software stacks. On the other hand, \emph{process virtual
machines} execute a single computer program by providing an execution
environment suitable for a particular programming language, which can be
platform-independent.

Process \gls{VM}s provide a so called \emph{runtime environment}. They run as
a normal application inside the host operating system. This approach has
several advantages:

\begin{itemize}
	\item Provides a platform-independent programming environment,
		abstracting away details of the underlying hardware or operating system,
		potentially allowing a program to execute in the same way on any platform.
	\item The level of abstraction provided by the \gls{VM} is higher than that
		of a low-level \gls{ISA}, which allows it to provide services rarely
		available in real machines (e.g. automatic memory management).
	\item There is an additional level of isolation between the operating system
		and the execution environment. This allows discretionary control over the
		executed code, which is confined to the bounds allowed by the \gls{VM}.
\end{itemize}

The main downside of virtual machines is the lower performance compared to the
execution of native code. Performance levels comparable to compiled languages
can be obtained using a combination of \gls{JIT} compilation (see
\autoref{sec:jit-compilers}), and compiler-based optimization techniques
specifically designed for them.

In some regards, the additional level of isolation provided by a \gls{VM}
could be a nuisance due to the fact that it could prevent programs from
accessing resources (either hardware-based, or provided by the host system)
needed for its operation. For this reason, many virtual machines provide
a \gls{FFI}: a mechanism to call-out native code and re-gain access to the
whole system, while still being under the control and supervision of the
\gls{VM}.


\subsection{JIT Compilers}
	\label{sec:jit-compilers}


\subsection{Foreign Function Interfaces}
	\label{sec:context-ffis}


\subsection{The Lua programming language}
	\label{sec:lua-programming-lang}

The Lua language is a “powerful, fast, lightweight, embeddable scripting
language” \cite{lua-about}. It was initially created as a data description
language at \gls{PUC-Rio}, to be used for in-house software development, and
has since evolved into a general purpose programming language. It has been
used in proffessional applications (e.g. Adobe Lightroom) and it has seen
widespread usage in the video games industry (e.g. World Of Warcraft).

% \begin{figure}[h]
% 	\centering
% 	\includegraphics[width=0.25\textwidth]{img/lua-logo}
% 	\caption{The Lua logo. “Lua” means “moon” in Portuguese.}
% 	\label{fig:lua-logo}
% \end{figure}

\begin{listing}
  \begin{luacode}
    -- Create a table, with one key, "age" and 7 as value
    animal = { age = 7 }

    -- Associate a string value to the "kind" table key
    animal["kind"] = "cat"

    -- Keys which are valid identifiers can be accessed with "."
    animal.name = "Doraemon"

    -- The dot "." syntax workds for adding functions to tables
    function animal.describe(self)
      print(self.name .. " is a " .. tostring(self.age) ..
            "-year old " .. self.kind)
    end

    -- This is equivalent to: animal.describe(animal)
    animal:describe()  --> Doraemon is a 7-year old cat

    -- Adding a function with colon ":" adds an implicit "self"
    function animal:furryness()
      return self.kind == "cat" and "high" or "unknown"
    end

    animal:furryness()  --> high
  \end{luacode}
	\caption{Lua tables being used as objects}
  \label{lst:lua-example-tables}
\end{listing}

Lua's main programming paradigm is imperative, but the language supports
functions as \glspl{first-class-value} and \glspl{closure}, making it possible
to easily write programs in a functional programming style. Like in
\gls{pascal}, English words (\Mlua|function|, \Mlua|then|, \Mlua|end|) are
used as delimiters for language constructs. Another defining characteristic of
the language is that, by design, it only provides one compound data structure,
the \emph{table}, which is the basis for all user--defined types. Tables can
be used as arrays (listing \ref{lst:lua-example-memoize}), structures, and
objects (listing \ref{lst:lua-example-tables}).

A unique and powerful feature of Lua is its support for \emph{metatables}:
values may have an associated table (the so-called \emph{metatable}) which
allows to extend the semantics of language constructs, allowing to define how
tables behave when arithmetic and relational operators are applied to tables,
or how table fields are accessed. Listing \vref{lst:lua-example-memoize}
demostrates how customizing table access can be used to define a
seemingly--infinite array which contains the $n^{th}$ \gls{fibonacci-number}
at index $n$. A common use for metatables is enabling support for
object--oriented programming, using them to define object inheritance chains
(listing \ref{lst:lua-example-meta-oo}) --- as Lua itself does not have the
notion of classes, prototypes are used instead, as in the Self or JavaScript
languages.

\begin{listing}
  \begin{luacode}
    fib = { 1, 1 }
    setmetatable(fib, {
      __index = function (values, n)
        -- Calculate and memoize the Fibonacci(n)
        values[n] = values[n - 1] + values[n - 2]
        return values[n]
      end
    })
    print(fib[10])  --> 55
  \end{luacode}
  \caption{\Gls{memoization} and \gls{dynamic-programming} using a Lua metatable}
	\label{lst:lua-example-memoize}
\end{listing}

\begin{listing}
  \begin{luacode}
    -- Base object describing an unnamed living creature
    animal = {
      name = "Unnamed",
      kind = "living creature",
      describe = function (self)
        print(self.name .. " is a " .. self.kind)
      end,
    }

    -- When indexing the table passed as first argument, fields will
    -- be looked up from the "animal" table associated to the "__index"
    -- key of the metatable. The function returns the first argument.
    cat = setmetatable({ kind = "cat", name = "Doraemon" },
                       { __index = animal })
    dog = setmetatable({ kind = "dog", name = "Snowy", },
                       { __index = animal })

    -- The :describe() method is searched in "animal"
    cat:describe()  --> Doraemon is a cat
    dog:describe()  --> Snowy is a dog

    -- Chained key lookup can be used to make the values from the
    -- base object the default ones
    tom = setmetatable({ name = "Tom" }, { __index = animal  })
    tom:describe()  --> Tom is a living creature
  \end{luacode}
  \caption{Lua metatables used for object inheritance}
  \label{lst:lua-example-meta-oo}
\end{listing}

Lua, starting in version 5.0~\cite{lua50-impl}, uses a register-based virtual
machine. This allows for improved performance by avoiding excessive copying of
values on stack \emph{pop} and \emph{push} operations. Traditionally, most
virtual machines intended for execution of languages are stack based,
including heavyweight, enterprise-proven systems like the Java™ JVM, and
Microsoft's .NET environment.


\section{Binding Native Code to Lua}

\subsection{Lua C API}
	\label{sec:lua-c-api}

% Plain API
% API wrappers

\subsection{Binding Generators}

Binding generators are tools that can be used to create a binding to a library
in an automated way. Often they fall into the category of \glspl{transpiler}:
they take as input the source code of the code to generate a binding for,
and generate a new set of source files which contain the code of the binding.
This set of source files are themselves compiled into a loadable module for
the target programming language or virtual machine, making it a
\emph{build-time} solution.

More than often, binding generators do \emph{not} include a full parser for
the programming language of origin, and they require to be fed a simplified
version of the code being wrapped. This can be a nuisance for code bases which
use complex language constructs unsupported by the binding generator.

\todo[inline]{Mention binding generators: SWIG, ToLua(++)}

% \minisec{Example: SWIG}
%
% The most widely known Open Source binding generator is probably
% SWIG\footnote{\url{http://swig.org}}, which supports creating bindings for
% multiple programming languages — since version 1.3.26 Lua is just one of the
% supported targets. SWIG has the ability of reading C/C++ header files as
% input, and it includes a fairly complete C/C++ parser.


\subsection{Foreign Function Interfaces}


\todo[inline]{Mention: GObject-Introspection, LuaJIT FFI}
% Examples:
%
% GObject-Introspection
% LuaJIT FFI
% Standalone FFI module

\section{Executable Formats}

\subsection{ELF}

The “Executable and Linkable Format” (ELF, formerly called “Extensible Linking
Format”) is a common standard file format for executable programs, object
code, shared libraries, and even core dumps. Since its publication as part of
the System V Release 4 (SVR4) Application Binary Interface (ABI) specification
\cite[c.~4]{elfspec-sysv}
it has been adopted by many Unix-like (Solaris, most of the BSD variants,
GNU/Linux), and non-Unix operating systems (most notably, OpenVMS, BeOS, and
its successor Haiku).

\subsection{DWARF}

The DWARF Specification \cite{dwarfspecv4}


