% vim: ft=tex spell spelllang=en ts=2 sw=2

\chapter{Contextualization}
% TODO: \minitoc ?

Computing would not be understood without the accompanying tools which enable
IT professionals to actually \emph{do something} with computers: from simple
switches and lights in the early times, to the sophisticated programming
languages and tools of the present times, all of them enable humans to
\emph{instruct machines to do things}.

%% TODO

\section{Dynamic Programming Languages}

Dynamic languages \todo{Add bibliographic reference} are a family of
high-level programming languages which, at runtime, execute programming
behaviors that other programming languages perform during compilation. Runtime
behaviors could include extension of the program, by adding new code, by
extending objects and definitions, or by modifying the type system. Support
for these operations is provided directly by the language. Most dynamic
languages are also dynamically typed, and are frequently called “scripting
languages”.

Popular contemporary scripting languages include Perl, Python, PHP, the
ubiquitous JavaScript, and of course Lua (described in
\autoref{sec:lua-programming-lang}). Many of their features were first
implemented as native features of the Lisp programming language, which itself
is dynamic.

Dynamic programming languages have grown in popularity in the last decades.
Programmers like them for their expressiveness, which allows for higher
productivity, and the ever increasing computing power of computers makes it
feasible to use them for performance-critical tasks traditionally left for
statically compiled languages. The development of novel compilation techniques
aimed at this family of languages, and the relentless improvement of their
virtual machines (see \autoref{sec:virtual-machines}), has contributed as well
to increase widespread adoption.

\subsection{Virtual Machines as Runtime Environments}
  \label{sec:virtual-machines}

A \gls{VM} is an \gls{emulation} of a particular computer system based on its
architecture. \emph{System virtual machines} provide a complete substitute for
the real machine, and targeted towards the execution of complete operating
systems and software stacks. On the other hand, \emph{process virtual
machines} execute a single computer program by providing an execution
environment suitable for a particular programming language, which can be
platform-independent.

Process \gls{VM}s provide a so called \emph{runtime environment}. They run as
a normal application inside the host operating system. This approach has
several advantages:

\begin{itemize}
	\item Provides a platform-independent programming environment,
		abstracting away details of the underlying hardware or operating system,
		potentially allowing a program to execute in the same way on any platform.
	\item The level of abstraction provided by the \gls{VM} is higher than that
		of a low-level \gls{ISA}, which allows it to provide services rarely
		available in real machines (e.g. automatic memory management).
	\item There is an additional level of isolation between the operating system
		and the execution environment. This allows discretionary control over the
		executed code, which is confined to the bounds allowed by the \gls{VM}.
\end{itemize}

The main downside of virtual machines is the lower performance compared to the
execution of native code. Performance levels comparable to compiled languages
can be obtained using a combination of \gls{JIT} compilation (see
\autoref{sec:jit-compilers}), and compiler-based optimization techniques
specifically designed for them.

In some regards, the additional level of isolation provided by a \gls{VM}
could be a nuisance due to the fact that it could prevent programs from
accessing resources (either hardware-based, or provided by the host system)
needed for its operation. For this reason, many virtual machines provide
a \gls{FFI}: a mechanism to call-out native code and re-gain access to the
whole system, while still being under the control and supervision of the
\gls{VM}.


\subsection{JIT Compilers}
	\label{sec:jit-compilers}



A \gls{JIT} compiler works by compiling code during the execution of programs
—at runtime—, instead of doing it before execution. This is also known as
\emph{dynamic translation}. Typically a VM which uses JIT compilation will
performa a quick translation of the input source code into an intermediate
representation known as \emph{bytecode}. This can be interpreted by the VM, or
used as input for JIT compilation if deemed neccessary. Most VMs record
statistics about which parts of the bytecode are used more often, and use the
slower JIT compiler to provide optimized versions. Depending on the
implementation, this will be done per source file, per function, or even for
arbitrary code fragments. Some VMs do not provide a bytecode interpreter and
must always generate machine code, so in order to avoid slow startup times, at
first a basic, faster JIT compiler is used, and then recompile fragments of
the code using an optimizing, slower compiler.

Code generated by JIT compilers offers better performance than interpreters,
and in some cases it can perform better than statically compiled code because
a JIT compiler can use optimizations which are only feasible at runtime:

\begin{itemize}

	\item Generated code can be optimized for the exact processor and operating
	system where the application runs. This can be done with traditional
	compilers, but it requires compiling the code once for each combination of
	target processor and operating system.

	\item The VM can collect statistics about how the program is running, and
	rearrange and recompile the code according to them.

	\item The compiler can make optimistic assumptions about the program,
	generate machine code that works optimally in most of the situations, plus
	additional checks to know whether the assumptions hold, falling back to
	using a slower implementation (or recompiling) otherwise. For example, this
	is used to inline method calls assuming that \gls{dynamic-dispatch} will not
	be needed, and performing the dynamic dispatch when the types of the
	involved objects to not match the ones assumed.

	\item Code can be rearranged after observing how it uses the cache memory to
	make a better usage of it.

\end{itemize}

The introduction of JIT compilation in VMs has allowed existing dynamic
languages to achieve levels of performance comparable to those of languages
compiled to machine code\todo{Maybe add a citation}. The JavaScript
programming language is a paradigmatic example: it has existed since 1995, yet
it has gained much more widespread usage after the introduction in 2008 of
JavaScript engines capable of JIT compilation (Mozilla's TraceMonkey was the
first, with Google's V8 and WebKit's JavaScriptCode following right
after~\cite{js-raceforspeed}), making it feasible to use JavaScript as
a general purpose language outside of web browsers.


\subsection{The Lua programming language}
	\label{sec:lua-programming-lang}

The Lua language is a “powerful, fast, lightweight, embeddable scripting
language” \cite{lua-about}. It was initially created as a data description
language at \gls{PUC-Rio}, to be used for in-house software development, and
has since evolved into a general purpose programming language. It has been
used in proffessional applications (e.g. Adobe Lightroom) and it has seen
widespread usage in the video games industry (e.g. World Of Warcraft).

% \begin{figure}[h]
% 	\centering
% 	\includegraphics[width=0.25\textwidth]{img/lua-logo}
% 	\caption{The Lua logo. “Lua” means “moon” in Portuguese.}
% 	\label{fig:lua-logo}
% \end{figure}

\begin{listing}
  \begin{luacode}
    -- Create a table, with one key, "age" and 7 as value
    animal = { age = 7 }

    -- Associate a string value to the "kind" table key
    animal["kind"] = "cat"

    -- Keys which are valid identifiers can be accessed with "."
    animal.name = "Doraemon"

    -- The dot "." syntax workds for adding functions to tables
    function animal.describe(self)
      print(self.name .. " is a " .. tostring(self.age) ..
            "-year old " .. self.kind)
    end

    -- This is equivalent to: animal.describe(animal)
    animal:describe()  --> Doraemon is a 7-year old cat

    -- Adding a function with colon ":" adds an implicit "self"
    function animal:furryness()
      return self.kind == "cat" and "high" or "unknown"
    end

    animal:furryness()  --> high
  \end{luacode}
	\caption{Lua tables being used as objects}
  \label{lst:lua-example-tables}
\end{listing}

Lua's main programming paradigm is imperative, but the language supports
functions as \glspl{first-class-value} and \glspl{closure}, making it possible
to easily write programs in a functional programming style. Like in
\gls{pascal}, English words (\Mlua|function|, \Mlua|then|, \Mlua|end|) are
used as delimiters for language constructs. Another defining characteristic of
the language is that, by design, it only provides one compound data structure,
the \emph{table}, which is the basis for all user--defined types. Tables can
be used as arrays (listing \ref{lst:lua-example-memoize}), structures, and
objects (listing \ref{lst:lua-example-tables}).

A unique and powerful feature of Lua is its support for \emph{metatables}:
values may have an associated table (the so-called \emph{metatable}) which
allows to extend the semantics of language constructs, allowing to define how
tables behave when arithmetic and relational operators are applied to tables,
or how table fields are accessed. Listing \vref{lst:lua-example-memoize}
demostrates how customizing table access can be used to define a
seemingly--infinite array which contains the $n^{th}$ \gls{fibonacci-number}
at index $n$. A common use for metatables is enabling support for
object--oriented programming, using them to define object inheritance chains
(listing \ref{lst:lua-example-meta-oo}) --- as Lua itself does not have the
notion of classes, prototypes are used instead, as in the Self or JavaScript
languages.

\begin{listing}
  \begin{luacode}
    fib = { 1, 1 }
    setmetatable(fib, {
      __index = function (values, n)
        -- Calculate and memoize the Fibonacci(n)
        values[n] = values[n - 1] + values[n - 2]
        return values[n]
      end
    })
    print(fib[10])  --> 55
  \end{luacode}
  \caption{\Gls{memoization} and \gls{dynamic-programming} using a Lua metatable}
	\label{lst:lua-example-memoize}
\end{listing}

\begin{listing}
  \begin{luacode}
    -- Base object describing an unnamed living creature
    animal = {
      name = "Unnamed",
      kind = "living creature",
      describe = function (self)
        print(self.name .. " is a " .. self.kind)
      end,
    }

    -- When indexing the table passed as first argument, fields will
    -- be looked up from the "animal" table associated to the "__index"
    -- key of the metatable. The function returns the first argument.
    cat = setmetatable({ kind = "cat", name = "Doraemon" },
                       { __index = animal })
    dog = setmetatable({ kind = "dog", name = "Snowy", },
                       { __index = animal })

    -- The :describe() method is searched in "animal"
    cat:describe()  --> Doraemon is a cat
    dog:describe()  --> Snowy is a dog

    -- Chained key lookup can be used to make the values from the
    -- base object the default ones
    tom = setmetatable({ name = "Tom" }, { __index = animal  })
    tom:describe()  --> Tom is a living creature
  \end{luacode}
  \caption{Lua metatables used for object inheritance}
  \label{lst:lua-example-meta-oo}
\end{listing}

Lua, starting in version 5.0~\cite{lua50-impl}, uses a register-based virtual
machine. This allows for improved performance by avoiding excessive copying of
values on stack \emph{pop} and \emph{push} operations. Traditionally, most
virtual machines intended for execution of languages are stack based,
including heavyweight, enterprise-proven systems like the Java™ JVM, and
Microsoft's .NET environment.


\section{Binding Native Code to Lua}

\subsection{Lua C API}
	\label{sec:lua-c-api}

The Lua \gls{VM} exposes a C \gls{API} which, among other things, allows to
register C functions to be called by Lua code. These communicate with the VM
using a well-defined protocol (see listing \ref{lst:lua-c-api-example}
for an example).

\begin{listing}[ht]
	\begin{ccode}
  int sum_and_average (lua_State *L) {
    lua_Number result = 0.0;
    int nargs = lua_gettop (L); /* number or arguments */
    for (int i = 1; i <= n; i++) {
      if (!lua_isnumber (L, i)) {
        lua_pushliteral (L, "argument is not a number");
        lua_error (L);
      }
      result += lua_tonumber (L, i);
    }
    lua_pushnumber (L, result);        /* first result */
    lua_pushnumber (L, result / n);   /* second result */
    return 2;                     /* number of results */
  }
	\end{ccode}
	\caption{C function callable from Lua}
	\label{lst:lua-c-api-example}
\end{listing}

Despite Lua providing a register-based VM, the C API uses a \emph{virtual
stack} to exchange values with C code. When a C function is called, it gets
a new stack, initially containing the arguments passed to the function, and
it must adhere to the following protocol:

\begin{itemize}
	\item C functions must be declared as returning an \Mc|int|, and accept
		a single \Mc|lua_State*| parameter. This is, their function pointer
		type is compatible with \Mc|lua_CFunction|, which Lua defines as:
		\begin{ccode}
			typedef int (*lua_Cfunction) (lua_State*);
		\end{ccode}

	\item The C function receives arguments from Lua in its call stack in
		direct order (the first argument is pushed first by the VM). The size of
		the stack —at this point the number of arguments— can be queried using
		\Mc|lua_gettop()|, and values can be obtained using the \verb|lua_to*()|
		functions.

	\item To return values back to Lua, the C function pushes them onto the
		stack in direct order (the first result is pushed first) using the
		\verb|lua_push*()| functions.

	\item The C function passes control to the VM returning the number of
		results available at the top of the stack. Any values left in the
		stack below the results are discarded.

\end{itemize}

The C API provided by Lua is comprehensive, but using it tends to produce
verbose programs, with varying amounts of repeated code. Lua itself
acknowledges this issue by officially including an \emph{auxiliar library}
as part of the package, which provides a collection of utility functions
implemented using the base API. Third-party wrappers over the official API
exist, which can either provide a more convenient interface to Lua (like
LuaAutoC\footnote{\url{https://github.com/orangeduck/LuaAutoC}}, and
\verb|luapi|\footnote{\url{http://lua-users.org/files/wiki_insecure/users/luapi/luapi5-1.txt}}),
or allow languages other than C to use Lua (more than
20 at the time of writing, including support for many popular languages like
C++, Objective-C, Go, Java, or Fortran).


\subsection{Binding Generators}
	\label{sec:binding-generators}

Binding generators are tools that can be used to create a binding to a library
in an automated way. Often they fall into the category of \glspl{transpiler}:
they take as input the source code of the code to generate a binding for,
and generate a new set of source files which contain the code of the binding.
This set of source files are themselves compiled into a loadable module for
the target programming language or virtual machine, making it a
\emph{build-time} solution.

More than often, binding generators do \emph{not} include a full parser for
the programming language of origin, and they require to be fed a simplified
version of the code being wrapped. This can be a nuisance for code bases which
use complex language constructs unsupported by the binding generator.

A popular, general-purpose binding generator is
SWIG\footnote{\url{http://swig.org}} (Simple Wrapper and Interface Generator),
which supports creating bindings for multiple programming languages, with Lua
being just one more of the supported targets. SWIG uses its own C/C++ parser,
which, while being complete~\cite{swig3doc}, still fails on certain inputs.

There are also Lua-specific binding generators, of which the
\gls{lua-users-wiki} provides a comprehensive
list~\cite{lusers-BindingCodeToLua}. The oldest is
ToLua\footnote{\url{http://www.tecgraf.puc-rio.br/~celes/tolua/}}, maintained
by staff from \gls{PUC-Rio} like Lua itself. Being Lua the only target
language, bindings generated by ToLua —and derivatives like ToLua++— are more
idiomatic that those generated by e.g. SWIG. As a downside, ToLua's parser is
quite limited, and only recognizes a subset of C and C++, to the point that it
is advised to provide a \emph{cleaned header file} containing only
declarations of data types, functions, and C++ classes recognizable by its
parser.


\subsection{Foreign Function Interfaces}
	\label{sec:ffis}

In its most generic meaning, a \gls{FFI} is any mechanism which allows
a program written in a programming language to call code or use services
written in another. In the Lua community, a FFI refers specifically to such
a mechanism which works at run time. That is, it \emph{does not} require using
the Lua C API (\autoref{sec:lua-c-api}), it is not a binding generator used at
build time (\autoref{sec:binding-generators}), nor is it a wrapper over the
Lua C API.

FFIs can be separated in two categories, depending on how they obtain the type
information (functions names, arguments, return values; and the data types of
all the values involved):

\begin{itemize}

	\item FFIs which require the programmer to supply type information.

	\item FFIs which obtain type information in an automated fashion.

\end{itemize}

The canonical example of a FFI which requires the programmer to enter type
information is the \gls{LuaJIT} FFI
module\footnote{\url{http://luajit.org/ext_ffi.html}}. Its functionality is
available as a regular Lua module which includes a number of support
functions, including the ability to parse C-style declarations to obtain type
information. Under the hood, the module generates the machine code for wrapper
functions —of type \Mc|lua_CFunction| (c.f. \autoref{sec:lua-c-api})— using
the LuaJIT code generator, which are directly callable (example in listing
\autoref{lst:luajit-ffi-example}). A standalone
\verb|luaffi|\footnote{\url{https://github.com/jmckaskill/luaffi}} module for
the standard Lua \gls{VM} exists, which has the same interface as the LuaJIT
FFI module, and even reuses its code generator.

\begin{listing}
	\begin{luacode}
  local ffi = require("ffi")
  ffi.cdef("int printf(const char *fmt, ...);")
  ffi.C.printf("Hello %s!\n", "world")
	\end{luacode}
	\caption{Using a C function with the LuaJIT FFI}
	\label{lst:luajit-ffi-example}
\end{listing}

Where the LuaJIT FFI requires the programmer to enter C-style declarations of
functions, LGI\footnote{\url{https://github.com/pavouk/lgi/}} uses the type
information supplied by the GObject-Introspection to provide access to
most of the libraries included as part of the
GNOME\footnote{\url{http://gnome.org}} desktop environment. The type
information supplied by GObject-Introspection is extracted from the source
code of the GNOME destop components at compile-time, and stored on disk in its
own file format. The included \verb|libgirepository| library is then used by
LGI to allow enumerate the available modules and their contents, as well as
allowing calling functions transparently from Lus. The metadata recorded by
GObject-Introspection when scanning source code includes additional
information in specially formatted comments, which allows LGI to create
idiomatic object oriented interfaces (c.f.
listing~\autoref{lst:lua-lgi-example}).

\begin{listing}
	\begin{luacode}
	local lgi = require("lgi")
	local Gtk = lgi.Gtk

	local w = Gtk.Window {
		title = "LGI Example",
		child = Gtk.Button { label = "Close",
			                   on_clicked = Gtk.main_quit },
	}
	w:show_all()
	Gtk.main()
	\end{luacode}
	\caption{Using the GTK+ user interface toolkit via GObject-Introspection}
	\label{lst:lua-lgi-example}
\end{listing}

\section{Executable Formats}

\subsection{ELF}

The “Executable and Linkable Format” (ELF, formerly called “Extensible Linking
Format”) is a common standard file format for executable programs, object
code, shared libraries, and even core dumps. Since its publication as part of
the System V Release 4 (SVR4) Application Binary Interface (ABI) specification
\cite[c.~4]{elfspec-sysv}
it has been adopted by many Unix-like (Solaris, most of the BSD variants,
GNU/Linux), and non-Unix operating systems (most notably, OpenVMS, BeOS, and
its successor Haiku).

\subsection{DWARF}

The DWARF Specification \cite{dwarfspecv4}


