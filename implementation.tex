% vim: ft=tex spell spelllang=en ts=2 sw=2 et foldlevel=2

\chapter{Implementation}


\section{Project Source Structure}

The \Eol* source code is organized in the following directory structure, which
follows usual conventions for C projects:

\begin{figure}[h]
    \centering
    \noindent\begin{minipage}{0.75\textwidth}
\dirtree{%
.1 \DtFolder{lua-eol/}.
.2   \DtFolder{doc/} \DTcomment{Documentation and API reference}.
.2   \DtFolder{examples/}.
.3     *.lua \DTcomment{Module usage examples}.
.2   \DtFolder{tools/} \DTcomment{Build \& test utilities}.
.3     \DtFolder{ninja/} \DTcomment{Ninja build support files}.
.3     \DtFolder{make/} \DTcomment{GNU Make build support files}.
.2   \DtFolder{test/}.
.3     *.lua \DTcomment{Unit tests}.
.2   uthash.h \DTcomment{Copy of UT-hash}.
.2   eol-*.c \DTcomment{Module sources}.
.2   eol-*.h \DTcomment{Module sources}.
}
    \end{minipage}
    \caption{Source tree structure.}
\end{figure}

Module source files (\verb|eol-*.h|, \verb|eol-*.c|) are named after the
components identified during the design phase. In particular:

\begin{itemize}

  \item \verb|eol-module.c| \hfill\\
    Main part of the code, including the interfacing with Lua.

  \item \verb|eol-fcall.h|,
        \verb|eol-fcall-<name>.h|,
        \verb|eol-fcall-<name>.c|... \hfill\\
    Different implementations of the native function invocation mechanism.

  \item \verb|eol-typing.h|, \verb|eol-typing.c| \hfill\\
    Type representation module.

  \item \verb|eol-typecache.h|, \verb|eol-typecache.c|, \verb|uthash.h| \hfill\\
    Type representation cache module.

  \item \verb|eol-libdwarf.h|, \verb|eol-libdwarf.c| \hfill\\
    Utility functions to simplify working with \verb|libdwarf|.

  \item \verb|eol-lua.h| \hfill\\
    Utility functions to simplify working with the Lua C API.

  \item \verb|eol-trace.h|, \verb|eol-trace.c| \hfill\\
    Tracing support module.

  \item \verb|eol-util.h|, \verb|eol-util.c| \hfill\\
    Miscellaneous utility code, including support code for the runtime checks.

\end{itemize}


\section{Type Representation}

Converting values from C to Lua, and vice versa, is one of the most important
tasks performed by \Eol*: C values need to be made accessible from Lua.
Therefore, this information needs to be read from the DWARF debugging
information (see \nameref{sec:debuginfo-structure}), and kept around in
a suitable data structure. This structure must be:

\begin{itemize}
  \item Exhaustive, to hold all the needed information.
  \item Compact, to minimize memory usage.
\end{itemize}

Describing base types is possible using just an enumerated type: there is
a fixed amount of them, and the characteristics (size, name, etc) are well
known. The challenging part is representing user defined types (\Mc|struct|,
\Mc|enum|, \Mc|union|), and derived types (pointers, arrays).

The data structure for describing types is \verb|EolTypeInfo| (listing
\vref{lst:EolTypeInfo}). It is a tagged \Mc|struct|, with the tag
indicatingthe type kind (\verb|EOL_TYPE_S32| for 32-bit signed integers,
\verb|EOL_TYPE_STRUCT| for a \Mc|struct|, etc; the complete list of values
can be seen in listing \vref{lst:EolType}). The contained data will vary
depending on the value of the \emph{kind} tag. The members for all possible
values are grouped in an \mintinline{c}{union} in order to make them share the
same memory space.

\begin{listing}[H]
  \begin{ccode}
    struct _EolTypeInfo {
      EolType type;
      union {
        struct TI_base     ti_base;
        struct TI_pointer  ti_pointer;
        struct TI_typedef  ti_typedef;
        struct TI_const    ti_const;
        struct TI_array    ti_array;
        struct TI_compound ti_compound;
      };
    };
    typedef struct _EolTypeInfo EolTypeInfo;
  \end{ccode}
  \caption{\texttt{EolTypeInfo}.}
  \label{lst:EolTypeInfo}
\end{listing}

\begin{listing}[tH]
  \centering
  \begin{ccode}
    typedef enum {
      EOL_TYPE_VOID,    /* void        */
      EOL_TYPE_BOOL,    /* _Bool       */
      EOL_TYPE_S8,      /* int8_t      */
      EOL_TYPE_U8,      /* uint8_t     */
      EOL_TYPE_S16,     /* int16_t     */
      EOL_TYPE_U16,     /* uint16_t    */
      EOL_TYPE_S32,     /* int32_t     */
      EOL_TYPE_U32,     /* uint32_t    */
      EOL_TYPE_S64,     /* int64_t     */
      EOL_TYPE_U64,     /* uint64_t    */
      EOL_TYPE_FLOAT,   /* float       */
      EOL_TYPE_DOUBLE,  /* double      */
      EOL_TYPE_TYPEDEF, /* typedef … T */
      EOL_TYPE_CONST,   /* const T     */
      EOL_TYPE_POINTER, /* T*          */
      EOL_TYPE_ARRAY,   /* T …[n]      */
      EOL_TYPE_STRUCT,  /* struct …    */
      EOL_TYPE_UNION,   /* union …     */
      EOL_TYPE_ENUM,    /* enum …      */
    } EolType;
  \end{ccode}
  \caption{\texttt{EolType} enumeration.}
  \label{lst:EolType}
\end{listing}


\begin{table}[f]
  \centering
  \begin{tabular}{lll}
    \toprule
    C Construct     & DWARF DIE                    & \Eol* Type            \\
    \midrule
    \Mc|void|       & ø                            & \Mc|EOL_TYPE_VOID|    \\
    \Mc|bool|       & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_BOOL|    \\
    \Mc|int8_t|     & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_S8|      \\
    \Mc|uint8_t|    & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_U8|      \\
    \Mc|int16_t|    & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_S16|     \\
    \Mc|uint16_t|   & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_U16|     \\
    \Mc|int32_t|    & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_S32|     \\
    \Mc|uint32_t|   & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_U32|     \\
    \Mc|int64_t|    & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_S64|     \\
    \Mc|uint64_t|   & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_U64|     \\
    \Mc|float|      & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_FLOAT|   \\
    \Mc|double|     & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_DOUBLE|  \\
    \Mc|typedef|... & \verb|DW_TAG_typedef|        & \Mc|EOL_TYPE_TYPEDEF| \\
    \Mc|const|...   & \verb|DW_TAG_const_type|     & \Mc|EOL_TYPE_CONST|   \\
    ...\Mc|*|       & \verb|DW_TAG_pointer_type|   & \Mc|EOL_TYPE_POINTER| \\
    ...\Mc|[n]|     & \verb|DW_TAG_array_type|     & \Mc|EOL_TYPE_ARRAY|   \\
    \Mc|struct|...  & \verb|DW_TAG_structure_type| & \Mc|EOL_TYPE_STRUCT|  \\
    \Mc|union|...   & \verb|DW_TAG_union_type|     & \Mc|EOL_TYPE_UNION|   \\
    \Mc|enum|...    & \verb|DW_TAG_enumration_type|& \Mc|EOL_TYPE_ENUM|    \\
    \bottomrule
  \end{tabular}
  \caption{Mapping of C types, DWARF DIEs and \Mc|EolType|.}
\end{table}

\noindent
The following sections describe in detail the members of \verb|EolTypeInfo|.


\subsection{Base Type Representation}

\begin{ccode*}{samepage=true}
  struct TI_base {
    char               *name;
    uint32_t            size;
  };
\end{ccode*}

\noindent
Even though it is sufficient to provide type kind codes for all the base types
as discussed before, providing the possibility of querying their \verb|name|
and \verb|size| is a convenient feature, at a very small cost: the
\verb|EolTypeInfo| value for each one of the base types is a singleton,
defined as follows:

\begin{ccode*}{samepage=true}
  /* File: eol-typing.h */
  extern const EolTypeInfo* eol_typeinfo_u32;

  /* File: eol-typing.c */
  const EolTypeInfo* eol_typeinfo_u32 = &((EolTypeInfo) {
    .kind         = EOL_TYPE_U32,
    .ti_base.name = "uint32_t",
    .ti_base.size = sizeof (uint32_t),
  });
\end{ccode*}

\noindent In practice, to avoid writing the definitions of all the base types,
the C preprocessor and a couple generator macros are used (see
\autoref{sec:cpp-abuse-genmacros}).


\subsection{Pointer Representation}
  \label{sec:pointer-typeinfo}

\begin{ccode*}{samepage=true}
  struct TI_pointer {
    const EolTypeInfo *typeinfo;
  };
\end{ccode*}

\noindent
Pointers are represented by referencing the \verb|EolTypeInfo| of the
pointed-to type. Thus, it is the only member in \Mc|struct TI_pointer|. The
size of a pointer value is platform dependent, but well known and constant for
each platform, and is the value of the C expression \Mc|sizeof(void*)|.


\subsection{Array Representation}

\begin{ccode*}{samepage=true}
  struct TI_array {
    const EolTypeInfo *typeinfo;
    uint64_t           n_items;
  };
\end{ccode*}

\noindent
Arrays are represented by referencing the \verb|EolTypeInfo| of the array
items, plus the number of items (\verb|n_items|) present in the array. The
size of an array value can be calculated multiplying the size of the item type
by the number of items in the array.


\subsection{User Defined Type Representation}

\begin{ccode*}{samepage=true}
  struct TI_compound {
    char             *name;
    uint32_t          size;
    uint32_t          n_members;
    EolTypeInfoMember members[];
  };
\end{ccode*}

\noindent This record type represents all user defined types: enumerated types
(\Mc:enum:), record types (\Mc:struct:), and union types (\Mc:union:):

\begin{description}
  \item [\Mc|name|] \hfill \\
    User defined types are usually given a name, but it is optional and in
    this case the value will be \Mc|NULL|.
  \item [\Mc|size|] \hfill \\
    Contains the size of the type, in bytes.
  \item [\Mc|n_members| / \Mc|members|] \hfill \\
    Count of members (or enumerators, for \verb|EOL_TYPE_ENUM|) in the type,
    and an array contaning their descriptions. Using
    a \gls{flexible-array-member}, allows usage of a single chunk of memory
    for the \verb|EolTypeInfo| itself and the items in the array.
\end{description}

\noindent
The auxiliar \verb|EolTypeInfoMember| type is defined as follows:

\begin{ccode*}{samepage=true}
  typedef struct {
    const char            *name;
    union {
      int64_t              value; /* enum */
      struct {                    /* union, struct */
        uint32_t           offset;
        const EolTypeInfo *typeinfo;
      };
    };
  } EolTypeInfoMember;
\end{ccode*}

\noindent
This always contains the (optional) \Mc|name| of the types, and usage of the
remaining fields varies with the type being described:

\begin{itemize}
  \item For \Mc|EOL_TYPE_STRUCT|, the \Mc|offset| of the member (in bytes,
    from the beginning of the record) and a pointer to its type information
    (\Mc|typeinfo|) are used.
  \item For \Mc|EOL_TYPE_UNION|, the \Mc|offset| is ignored, and only the
    type information of the member (\Mc|typeinfo|) is used.
  \item For \Mc|EOL_TYPE_ENUM|, only the \Mc|value| associated with the
    enumerator is used.
\end{itemize}

\noindent
An \Mc|union| is used to make fields share the same memory space.


\subsection{Type Alias Representation}

\begin{ccode*}{samepage=true}
  struct TI_typedef {
    char              *name;
    const EolTypeInfo *typeinfo;
  };
\end{ccode*}

Type aliases assign a name to an arbitrary type. They are represented by the
\Mc|name| and a pointer to the \Mc|EolTypeInfo| of the type.


\subsection{Read-only Type Representation}

\begin{ccode*}{samepage=true}
  struct TI_const {
    const EolTypeInfo *typeinfo;
  };
\end{ccode*}

\noindent
Flagging a type as read-only (i.e. using the \Mc|const| type qualifier in C)
is represented in the same way as pointers (\autoref{sec:pointer-typeinfo}):
by keeping a pointer to the \Mc|EolTypeInfo| that is read-only.




\section{Type cache}

The type cache is implemented as an opaque data structure which can only be
used by means of its public API (Listing \autoref{lst:eol-typecache-api}). Internally
it is implemented as a hash table which reuses uthash~\cite{uthash-guide}, and
it maps integer keys (\Mc|uint32_t|) to \Mc|EolTypeInfo| structures. Cache
keys can be any unique integer which uniquely identifies a particular type.
For a \Mc|EolTypeInfo| created from its DWARF representation, the offset of
the top-level \gls{DIE} is used as the key. This works because information for
a particular type is never duplicated inside the same ELF file, so there is an
unique offset in the file for it.

\begin{listing}[tH]
  \centering
\begin{ccode}
typedef struct _EolTypeCacheEntry* EolTypeCache;

typedef bool (*EolTypeCacheIter)  (EolTypeCache*,
                                   const EolTypeInfo*,
                                   void *userdata);

void eol_type_cache_init (EolTypeCache *cache);
void eol_type_cache_free (EolTypeCache *cache);

void eol_type_cache_add (EolTypeCache      *cache,
                         uint32_t           offset,
                         const EolTypeInfo *typeinfo);

const EolTypeInfo* eol_type_cache_lookup (EolTypeCache *cache,
                                          uint32_t      offset);

void eol_type_cache_foreach (EolTypeCache    *cache,
                             EolTypeCacheIter callback,
                             void             *userdata);
\end{ccode}
  \caption{Public API of \Mc|EolTypeCache|}.
  \label{lst:eol-typecache-api}
\end{listing}

The type cache only manages its own dynamically allocated memory, used for the
nodes of the hash table. The \Mc|EolTypeInfo| structures referenced by the
cache are considered opaque by the cache, and the memory used by them is not
ever freed by the cache: freeing the cache leaks memory if the cached entries
are not freed by other means. In practice, this is not a problem because the
type information is constructed as-needed, and cached during the whole
lifetime of each loaded ELF object. This approach allows to simply iterate
over the elements to free each one of them before unloading the object file.


\section{\Eol* Lua module}

The top-level API exposed to Lua is the \verb|eol| module, which has to be
returned by the C function that the Lua VM calls after loading an extension
module. This function is always called \verb|luaopen_<module>|, where
\verb|<module>| is the name of the module being loaded:

\begin{ccode}
LUAMOD_API int
luaopen_eol (lua_State *L)
{
  eol_trace_setup ();

  (void) elf_version (EV_NONE);
  if (elf_version (EV_CURRENT) == EV_NONE)
    return luaL_error (L, "outdated libelf version");

  luaL_newlib (L, eollib);
  create_meta (L);
  return 1;
}
\end{ccode}

Notice how the function uses \verb|luaL_newlib()| instead of manually creating
a table in the Lua stack, and setting a field for each one of the \verb|eol.*|
module level functions. The \verb|eollib| variable is defined as follows,
using the supplied \verb|luaL_Reg| type:

\begin{ccode}
static const luaL_Reg eollib[] = {
  { "load",     eol_load     },
  { "type",     eol_type     },
  { "sizeof",   eol_sizeof   },
  { "typeof",   eol_typeof   },
  { "offsetof", eol_offsetof },
  { "cast",     eol_cast     },
  { NULL, NULL },
};
\end{ccode}

As a last step, \verb|create_meta()| is called to register the metatables for
the C types which \Eol* exposes to the Lua VM (\vref{sec:eol-mod-typemeta}).

\subsection{Type Metatables}
  \label{sec:eol-mod-typemeta}

\subsection{Library loading}

  \verb|eol_load| \todo{Write}

\subsection{Type Information Lookup}

  \verb|eol_type| \todo{Write}

\subsection{Querying Types}

  \verb|eol_typeof|
  \verb|eol_sizeof|
  \verb|eol_offsetof|
  \todo{Write}

\subsection{Casting}

  \verb|eol_cast|


\section{Memory Ownership and Life Cycle}

Native code uses a different approach for memory management compared to Lua:
while Lua uses \gls{GC}, which handles freeing chunks of memory automatically,
native code frees memory explicitly. Take for example a function which creates
a new \Mc|struct| and returns it:

\begin{ccode*}{samepage=true}
struct point { int x; int y; };

struct point* point_new (int x, int y) {
  struct point *p = malloc (sizeof (struct point));
  p->x = x;
  p->y = y;
  return p;
}
\end{ccode*}

Then, that code is built into an ELF shared object file (\verb|point.so|),
which is loaded using \Eol*, and used normally:

\begin{luacode}
local Geometry = eol.load("point.so")
local point = Geometry.point_new(1, -1)
-- Use the point normally.
\end{luacode}

The Lua VM only knows the userdata that \Eol* has created to represent the
returned value, but it is not aware of the memory that has been allocated to
hold the \Mc|struct point| value. Once the value is not used anymore by the
Lua program, the garbage collector reclaims the space used by the userdata,
but \verb|free()| is not called to free the memory allocated by
\verb|malloc()|. Lua just does not know about memory that it has not allocated
itself. One solution is to manually call a function to free the memory from
Lua:

\begin{luacode}
local libc = eol.load("libc.so")
libc.free(point)
point = nil  -- Make sure it won't be used
\end{luacode}

The main problem with this is that the automatic memory management done by the
Lua VM is lost, and programmers are forced to write additional code to free
memory regions. This puts a burden in the developer, which would rather be
avoided.


\subsection{Lua as a Custom Allocator}

The Lua VM exposes in its C API the ability to create \emph{userdata} objects.
For the VM, userdata is seen as an opaque value which, by default, cannot be
manipulated from Lua; for the client code using the Lua API, an userdata value
is a region of memory allocated by the Lua VM, which can contain any data.
Like every other value managed by the VM, userdata is subject to \gls{GC},
which means that userdata values which are no longer referenced by a Lua
program are garbage collected. This effectively allows C programmers to reuse
the Lua GC for their data.

\begin{listing}[H]
  \centering
  \begin{ccode}
  struct data { /* ... */ };

  struct data* push_new_data (lua_State *L) {
    struct data *d = lua_newuserdata (L, sizeof (struct data));
    initialize_data (d);
    return d;
  }
  \end{ccode}
  \caption{Using Lua userdata to store values}
  \label{lst:values-in-userdata}
\end{listing}

By default, userdata values have no predefined behaviour in Lua, except for
assignment (which also covers passing userdata values as function parameters),
and testing for identity. Assigning a metatable to an userdata value allows
the programmer to define operations on userdata values.


\subsection{GC Finalization}

The only thing known by the Lua VM about userdata values is that they are
a region of memory. That means that Lua will only free the memory region when
the userdata is picked by the \gls{GC}. If the userdata contains resources
other than raw memory (a file handle, for example), it must be ensured that
those are released appropriately.

\todo[inline]{continue this}

\begin{listing}[H]
  \small
  \begin{center}
    \emph{C code}
  \end{center}
\begin{ccode}
/* Build with: cc -shared -o openlog.so openlog.c */

struct logger {
  FILE *output;
};

static int logger_call (lua_State *L) { /* ... */ }

static int logger_gc (lua_State *L) {
  struct logger *l = luaL_checkudata (L, 1, "LOGGER");
  if (l->output) fclose (l->output); /* Close the file */
  return 0;
}

static int logger_new (lua_State *L) {
  const char *path = luaL_checkstring (L, 1);
  lua_Integer verbosity = luaL_checkinteger (L, 2);
  struct logger *l = lua_newuserdata (L, sizeof (struct logger));
  if (!(l->output = fopen (path, "a")))
    return luaL_error (L, "cannot open (\%s)", strerror (errno));
  l->verbosity = (int) verbosity;
  luaL_setmetatable (L, "LOGGER");
  return 1;
}

int luaopen_openlog (lua_State *L) {
  static const luaL_Reg metamethods[] = {
    { "__call", logger_call, }
    { "__gc", logger_gc, }
    { NULL, NULL },
  };
  luaL_newmetatable (L, "LOGGER");
  luaL_setfuncs (L, metamethods, 0);
  lua_pushcfunction (L, logger_new);
  return 1;
}
\end{ccode}

  \begin{center}
    \emph{Using the module from Lua}
  \end{center}

\begin{luacode}
  local openlog = require("openlog")
  local log = openlog("/var/log/example.log", true)
  log("Log line")
\end{luacode}

  \caption{Small C module which demonstrates using a \texttt{\_\_gc} metamethod}
  \label{lst:lua-gc-example-module}
\end{listing}


\section{Miscellanea}

This section describes assorted techniques used in the implementation of
\Eol* which do not fall under a common umbrella, yet they deserve to be
mentioned.

\subsection{Preprocessor “Generator Macros”}
  \label{sec:cpp-abuse-genmacros}

This is a programming pattern used thorough the code of \Eol*: the
C preprocessor is used in a convoluted way as a rudimentary code generator
using lists of related elements. First, a macro of related elements is defined
(\emph{enumerator macro}, from now on), and it must accept the identifier for
another macro (the \emph{generator macro}) as a parameter. Each element in the
enumerator macro is an expansion of the generator, passing the parameters
needed by the generator.

In order to better understand how generator macros work, let us walk through
a complete example adapted from the \Eol* source code. The following macro
expands into a function which checks the type of an \Mc|EolTypeInfo| — it is
the \emph{generator}:

\begin{ccode*}{samepage=true}
#define MAKE_TYPEINFO_IS_TYPE(suffix, name, ctype)            \
    bool eol_typeinfo_is_ ## name (const EolTypeInfo *înfo) \
    { return info->type == EOL_TYPE_ ## suffix; }
\end{ccode*}

\noindent In generator macros like this, the concatenation operator
(\verb|##|) of the preprocessor is used extensively to build pieces of valid
C code. The example shows how the \verb|name| parameter is concatenated to
create the name of the generated function, and the \verb|suffix| parameter is
concatenated to create a valid \verb|EolType| (listing \vref{lst:EolType})
value. A valid expansion of the above macro is:

\begin{ccode*}{samepage=true}
MAKE_TYPEINFO_IS_TYPE (S32, s32, int32_t)
\end{ccode*}

\noindent
which generates the following valid C function:

\begin{ccode*}{samepage=true}
  bool eol_typeinfo_is_s32 (const EolTypeInfo *info)
  { return info->type == EOL_TYPE_S32; }
\end{ccode*}

\noindent The \emph{enumerator macro} is made by grouping a set of macro
expansions like the one above. The key is using a generic name for the
generator macro, which will be passed as a parameter. The next listing defines
an enumerator which expands a generator \verb|F| for each signed integer type:

\begin{ccode*}{samepage=true}
#define INTEGER_S_TYPES(F) \
    F (S8,  s8,  int8_t  ) \
    F (S16, s16, int16_t ) \
    F (S32, s32, int32_t ) \
    F (S64, s64, int64_t )
\end{ccode*}

\noindent Using the above definition, an expansion of the \emph{enumerator
macro} causes multiple expansions at once of the \emph{generator macro} passed
as \verb|F|, which in turn creates as many functions as elements in the
enumerator macro. In this example, using generator macros reduces the amount
of code that the programmer must write manually close to one fourth of the
original.

Another use case for generator macros is creating the code for cases in
a \Mc|switch| statement. Instead of constructing the code for an entire
function at a time, only a single \Mc|case| label and its associated
statements are generated. This is done in the following example:

\begin{ccode*}{samepage=true}
#define MAKE_SIGNED_TYPE_CASE(suffix, name, ctype) \
    case EOL_TYPE_ ## suffix: return true;

bool eol_type_is_signed (EolType type) {
  switch (type) {
    INTEGER_S_TYPES (MAKE_SIGNED_TYPE_CASE)
    default: return false;
  }
}
\end{ccode*}

