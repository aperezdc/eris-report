% vim: ft=tex spell spelllang=en ts=2 sw=2 et

\chapter{Implementation}

\section{Prerequisites}

\todo[inline]{Move this to an appendinx with manual / installation notes}.

Instead of providing its own implementation for certain functionality, \Eol*
uses existing, proved software components.

\begin{table}[h]
	\centering
	\begin{tabular}{lrccc}
		\toprule
		Component & Version  & Required & Optional & Bundled \\
		\midrule
		Lua             & 5.3      & \Tick &       & \Tick \\
		\verb|libdwarf| & 20150507 & \Tick &       & \Tick \\
		\verb|libelf|   & 0.152    & \Tick &       & \\
		\verb|readline| & 5.0      &       & \Tick & \\
		\verb|libffi|   & 3.1      & \Tick &       & \\
		\bottomrule
	\end{tabular}
	\caption{Dependencies}
	\label{tab:eol-dependencies}
\end{table}

\autoref{tab:eol-dependencies} shows the dependencies expected to be
installed in the system. The items marked (\inlinesymbol\Tick) as
\emph{bundled} are not included in the source repository, but the build system
includes support for downloading tarballs with the source code and doing
a local build. When enabled, bundled dependencies will be automatically
downloaded, built, and used instead instead of the versions provided by the
system. In the case of using \verb|libdwarf| bundled, it will be statically
linked. See~\autoref{sec:running-configure} for instructions for enabling
bundled libraries. This is particularly useful for systems which do not
provide Lua 5.3 packages (for example, the case Debian and Ubuntu at the time
of writing).

\begin{table}
  \begin{tabular}{ccp{0.4\textwidth}}
  \toprule
	Distribution & Installation Command & Packages \\
	\midrule
	Debian, Ubuntu &
    \verb|apt-get install| &
    \verb|libdwarf-dev| \verb|ninja-build| \\
	Arch Linux & \verb|pacman -S| & \verb|libdwarf| \verb|ninja| \verb|lua| \\
	\bottomrule
  \end{tabular}
  \caption{Dependency packages in popular GNU/Linux distributions.}
  \label{tab:distro-dependency-packages}
\end{table}

\autoref{tab:distro-dependency-packages} shows required packages as provided
by popular GNU/Linux distributions. Some versions of Debian (and derivatives
like Ubuntu) include only a static version of \verb|libdwarf| in the packages,
most likely not built as \gls{PIC}, which is a requirement.


\section{Build Tools}

\subsection{Autoconfiguration}
  \label{sec:running-configure}

\section{Project Source Structure}

The \Eol* source code

\begin{figure}[h]
    \centering
    \noindent\begin{minipage}{0.75\textwidth}
\dirtree{%
.1 \DtFolder{lua-eol/}.
.2   \DtFolder{doc/} \DTcomment{Documentation and API reference}.
.2   \DtFolder{examples/}.
.3     *.lua \DTcomment{Module usage examples}.
.2   \DtFolder{tools/} \DTcomment{Build \& test utilities}.
.3     \DtFolder{ninja/} \DTcomment{Ninja build support files}.
.3     \DtFolder{make/} \DTcomment{GNU Make build support files}.
.2   \DtFolder{test/}.
.3     *.lua \DTcomment{Unit tests}.
.2   uthash.h \DTcomment{Copy of UT-hash}.
.2   eol-*.c \DTcomment{Module sources}.
.2   eol-*.h \DTcomment{Module sources}.
}
    \end{minipage}
    \caption{Source tree structure.}
\end{figure}



\section{Type Representation}

Converting values from C to Lua, and vice versa, is one of the most important
tasks performed by \Eol*: C values need to be made accessible from Lua.
Therefore, this information needs to be read from the DWARF debugging
information (see \nameref{sec:debuginfo-structure}), and kept around in
a suitable data structure. This structure must be:

\begin{itemize}
  \item Exhaustive, to hold all the needed information.
  \item Compact, to minimize memory usage.
\end{itemize}

Describing base types is possible using just an enumerated type: there is
a fixed amount of them, and the characteristics (size, name, etc) are well
known. The challenging part is representing user defined types (\Mc|struct|,
\Mc|enum|, \Mc|union|), and derived types (pointers, arrays).

The data structure for describing types is \verb|EolTypeInfo| (listing
\vref{lst:EolTypeInfo}). It is a tagged \Mc|struct|, with the tag
indicatingthe type kind (\verb|EOL_TYPE_S32| for 32-bit signed integers,
\verb|EOL_TYPE_STRUCT| for a \Mc|struct|, etc; the complete list of values
can be seen in listing \vref{lst:EolType}). The contained data will vary
depending on the value of the \emph{kind} tag. The members for all possible
values are grouped in an \mintinline{c}{union} in order to make them share the
same memory space.

\begin{listing}[H]
  \begin{ccode}
    struct _EolTypeInfo {
      EolType type;
      union {
        struct TI_base     ti_base;
        struct TI_pointer  ti_pointer;
        struct TI_typedef  ti_typedef;
        struct TI_const    ti_const;
        struct TI_array    ti_array;
        struct TI_compound ti_compound;
      };
    };
    typedef struct _EolTypeInfo EolTypeInfo;
  \end{ccode}
  \caption{\texttt{EolTypeInfo}.}
  \label{lst:EolTypeInfo}
\end{listing}

\begin{listing}[f]
  \centering
  \begin{ccode}
    typedef enum {
      EOL_TYPE_VOID,    /* void        */
      EOL_TYPE_BOOL,    /* _Bool       */
      EOL_TYPE_S8,      /* int8_t      */
      EOL_TYPE_U8,      /* uint8_t     */
      EOL_TYPE_S16,     /* int16_t     */
      EOL_TYPE_U16,     /* uint16_t    */
      EOL_TYPE_S32,     /* int32_t     */
      EOL_TYPE_U32,     /* uint32_t    */
      EOL_TYPE_S64,     /* int64_t     */
      EOL_TYPE_U64,     /* uint64_t    */
      EOL_TYPE_FLOAT,   /* float       */
      EOL_TYPE_DOUBLE,  /* double      */
      EOL_TYPE_TYPEDEF, /* typedef … T */
      EOL_TYPE_CONST,   /* const T     */
      EOL_TYPE_POINTER, /* T*          */
      EOL_TYPE_ARRAY,   /* T …[n]      */
      EOL_TYPE_STRUCT,  /* struct …    */
      EOL_TYPE_UNION,   /* union …     */
      EOL_TYPE_ENUM,    /* enum …      */
    } EolType;
  \end{ccode}
  \caption{\texttt{EolType} enumeration.}
  \label{lst:EolType}
\end{listing}


\begin{table}[f]
  \centering
  \begin{tabular}{lll}
    \toprule
    C Construct     & DWARF DIE                    & \Eol* Type            \\
    \midrule
    \Mc|void|       & ø                            & \Mc|EOL_TYPE_VOID|    \\
    \Mc|bool|       & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_BOOL|    \\
    \Mc|int8_t|     & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_S8|      \\
    \Mc|uint8_t|    & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_U8|      \\
    \Mc|int16_t|    & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_S16|     \\
    \Mc|uint16_t|   & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_U16|     \\
    \Mc|int32_t|    & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_S32|     \\
    \Mc|uint32_t|   & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_U32|     \\
    \Mc|int64_t|    & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_S64|     \\
    \Mc|uint64_t|   & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_U64|     \\
    \Mc|float|      & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_FLOAT|   \\
    \Mc|double|     & \verb|DW_TAG_base_type|      & \Mc|EOL_TYPE_DOUBLE|  \\
    \Mc|typedef|... & \verb|DW_TAG_typedef|        & \Mc|EOL_TYPE_TYPEDEF| \\
    \Mc|const|...   & \verb|DW_TAG_const_type|     & \Mc|EOL_TYPE_CONST|   \\
    ...\Mc|*|       & \verb|DW_TAG_pointer_type|   & \Mc|EOL_TYPE_POINTER| \\
    ...\Mc|[n]|     & \verb|DW_TAG_array_type|     & \Mc|EOL_TYPE_ARRAY|   \\
    \Mc|struct|...  & \verb|DW_TAG_structure_type| & \Mc|EOL_TYPE_STRUCT|  \\
    \Mc|union|...   & \verb|DW_TAG_union_type|     & \Mc|EOL_TYPE_UNION|   \\
    \Mc|enum|...    & \verb|DW_TAG_enumration_type|& \Mc|EOL_TYPE_ENUM|    \\
    \bottomrule
  \end{tabular}
  \caption{Mapping of C types, DWARF DIEs and \Mc|EolType|.}
\end{table}

\noindent
The following sections describe in detail the members of \verb|EolTypeInfo|.


\subsection{Base Type Representation}

\begin{ccode*}{samepage=true}
  struct TI_base {
    char               *name;
    uint32_t            size;
  };
\end{ccode*}

\noindent
Even though it is sufficient to provide type kind codes for all the base types
as discussed before, providing the possibility of querying their \verb|name|
and \verb|size| is a convenient feature, at a very small cost: the
\verb|EolTypeInfo| value for each one of the base types is a singleton,
defined as follows:

\begin{ccode*}{samepage=true}
  /* File: eol-typing.h */
  extern const EolTypeInfo* eol_typeinfo_u32;

  /* File: eol-typing.c */
  const EolTypeInfo* eol_typeinfo_u32 = &((EolTypeInfo) {
    .kind         = EOL_TYPE_U32,
    .ti_base.name = "uint32_t",
    .ti_base.size = sizeof (uint32_t),
  });
\end{ccode*}

\noindent In practice, to avoid writing the definitions of all the base types,
the C preprocessor and a couple generator macros are used (see
\autoref{sec:cpp-abuse-genmacros}).


\subsection{Pointer Representation}
  \label{sec:pointer-typeinfo}

\begin{ccode*}{samepage=true}
  struct TI_pointer {
    const EolTypeInfo *typeinfo;
  };
\end{ccode*}

\noindent
Pointers are represented by referencing the \verb|EolTypeInfo| of the
pointed-to type. Thus, it is the only member in \Mc|struct TI_pointer|. The
size of a pointer value is platform dependent, but well known and constant for
each platform, and is the value of the C expression \Mc|sizeof(void*)|.


\subsection{Array Representation}

\begin{ccode*}{samepage=true}
  struct TI_array {
    const EolTypeInfo *typeinfo;
    uint64_t           n_items;
  };
\end{ccode*}

\noindent
Arrays are represented by referencing the \verb|EolTypeInfo| of the array
items, plus the number of items (\verb|n_items|) present in the array. The
size of an array value can be calculated multiplying the size of the item type
by the number of items in the array.


\subsection{User Defined Type Representation}

\begin{ccode*}{samepage=true}
  struct TI_compound {
    char             *name;
    uint32_t          size;
    uint32_t          n_members;
    EolTypeInfoMember members[];
  };
\end{ccode*}

\noindent This record type represents all user defined types: enumerated types
(\Mc:enum:), record types (\Mc:struct:), and union types (\Mc:union:):

\begin{description}
  \item [\Mc|name|] \hfill \\
    User defined types are usually given a name, but it is optional and in
    this case the value will be \Mc|NULL|.
  \item [\Mc|size|] \hfill \\
    Contains the size of the type, in bytes.
  \item [\Mc|n_members| / \Mc|members|] \hfill \\
    Count of members (or enumerators, for \verb|EOL_TYPE_ENUM|) in the type,
    and an array contaning their descriptions. Using
    a \gls{flexible-array-member}, allows usage of a single chunk of memory
    for the \verb|EolTypeInfo| itself and the items in the array.
\end{description}

\noindent
The auxiliar \verb|EolTypeInfoMember| type is defined as follows:

\begin{ccode*}{samepage=true}
  typedef struct {
    const char            *name;
    union {
      int64_t              value; /* enum */
      struct {                    /* union, struct */
        uint32_t           offset;
        const EolTypeInfo *typeinfo;
      };
    };
  } EolTypeInfoMember;
\end{ccode*}

\noindent
This always contains the (optional) \Mc|name| of the types, and usage of the
remaining fields varies with the type being described:

\begin{itemize}
  \item For \Mc|EOL_TYPE_STRUCT|, the \Mc|offset| of the member (in bytes,
    from the beginning of the record) and a pointer to its type information
    (\Mc|typeinfo|) are used.
  \item For \Mc|EOL_TYPE_UNION|, the \Mc|offset| is ignored, and only the
    type information of the member (\Mc|typeinfo|) is used.
  \item For \Mc|EOL_TYPE_ENUM|, only the \Mc|value| associated with the
    enumerator is used.
\end{itemize}

\noindent
An \Mc|union| is used to make fields share the same memory space.


\subsection{Type Alias Representation}

\begin{ccode*}{samepage=true}
  struct TI_typedef {
    char              *name;
    const EolTypeInfo *typeinfo;
  };
\end{ccode*}

Type aliases assign a name to an arbitrary type. They are represented by the
\Mc|name| and a pointer to the \Mc|EolTypeInfo| of the type.


\subsection{Read-only Type Representation}

\begin{ccode*}{samepage=true}
  struct TI_const {
    const EolTypeInfo *typeinfo;
  };
\end{ccode*}

\noindent
Flagging a type as read-only (i.e. using the \Mc|const| type qualifier in C)
is represented in the same way as pointers (\autoref{sec:pointer-typeinfo}):
by keeping a pointer to the \Mc|EolTypeInfo| that is read-only.


\section{Memory owners and life-cycle}

Problem: functions that allocate memory

\begin{ccode*}{samepage=true}
struct point {
	int x;
	int y;
};
\end{ccode*}

In Lua, we could create an instance like this:

\begin{luacode}
local Geometry = eol.wrap("libgeometry.so")
-- Creates heavy userdata, the Lua GC handles freeing memory
local point = Geometry.point { x = 1, y = -1 }
\end{luacode}

\todo[inline]{Complete this section}


\section{Miscellanea}

This section describes assorted techniques used in the implementation of
\Eol* which do not fall under a common umbrella, yet they deserve to be
mentioned.

\subsection{Preprocessor “Generator Macros”}
  \label{sec:cpp-abuse-genmacros}

This is a programming pattern used thorough the code of \Eol*: the
C preprocessor is used in a convoluted way as a rudimentary code generator
using lists of related elements. First, a macro of related elements is defined
(\emph{enumerator macro}, from now on), and it must accept the identifier for
another macro (the \emph{generator macro}) as a parameter. Each element in the
enumerator macro is an expansion of the generator, passing the parameters
needed by the generator.

In order to better understand how generator macros work, let us walk through
a complete example adapted from the \Eol* source code. The following macro
expands into a function which checks the type of an \Mc|EolTypeInfo| — it is
the \emph{generator}:

\begin{ccode*}{samepage=true}
#define MAKE_TYPEINFO_IS_TYPE(suffix, name, ctype)            \
    bool eol_typeinfo_is_ ## name (const EolTypeInfo *înfo) \
    { return info->type == EOL_TYPE_ ## suffix; }
\end{ccode*}

\noindent In generator macros like this, the concatenation operator
(\verb|##|) of the preprocessor is used extensively to build pieces of valid
C code. The example shows how the \verb|name| parameter is concatenated to
create the name of the generated function, and the \verb|suffix| parameter is
concatenated to create a valid \verb|EolType| (listing \vref{lst:EolType})
value. A valid expansion of the above macro is:

\begin{ccode*}{samepage=true}
MAKE_TYPEINFO_IS_TYPE (S32, s32, int32_t)
\end{ccode*}

\noindent
which generates the following valid C function:

\begin{ccode*}{samepage=true}
  bool eol_typeinfo_is_s32 (const EolTypeInfo *info)
  { return info->type == EOL_TYPE_S32; }
\end{ccode*}

\noindent The \emph{enumerator macro} is made by grouping a set of macro
expansions like the one above. The key is using a generic name for the
generator macro, which will be passed as a parameter. The next listing defines
an enumerator which expands a generator \verb|F| for each signed integer type:

\begin{ccode*}{samepage=true}
#define INTEGER_S_TYPES(F) \
    F (S8,  s8,  int8_t  ) \
    F (S16, s16, int16_t ) \
    F (S32, s32, int32_t ) \
    F (S64, s64, int64_t )
\end{ccode*}

\noindent Using the above definition, an expansion of the \emph{enumerator
macro} causes multiple expansions at once of the \emph{generator macro} passed
as \verb|F|, which in turn creates as many functions as elements in the
enumerator macro. In this example, using generator macros reduces the amount
of code that the programmer must write manually close to one fourth of the
original.

Another use case for generator macros is creating the code for cases in
a \Mc|switch| statement. Instead of constructing the code for an entire
function at a time, only a single \Mc|case| label and its associated
statements are generated. This is done in the following example:

\begin{ccode*}{samepage=true}
#define MAKE_SIGNED_TYPE_CASE(suffix, name, ctype) \
    case EOL_TYPE_ ## suffix: return true;

bool eol_type_is_signed (EolType type) {
  switch (type) {
    INTEGER_S_TYPES (MAKE_SIGNED_TYPE_CASE)
    default: return false;
  }
}
\end{ccode*}

