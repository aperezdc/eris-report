% vim: ft=tex spell spelllang=en

\chapter{Implementation}

\section{Prerequisites}

\begin{table}[h]
    \centering
    \begin{tabular}{lrccc}
	\toprule
	Component & Version  & Required & Optional & Bundled \\
	\midrule
	Lua             & 5.3      & \Tick    &          & \Tick   \\
	\verb|libdwarf| & 20150507 & \Tick    &          & \Tick   \\
	\verb|libelf|   & 0.152    & \Tick    &          &         \\
	\verb|readline| & 5.0      &          & \Tick    &         \\
	\verb|libffi|   & 3.1      & \Tick    &          &         \\
	\bottomrule
    \end{tabular}
    \caption{Dependencies}
    \label{tab:eris-dependencies}
\end{table}

\autoref{tab:eris-dependencies} shows dependencies expected to be installed in
the system. The items marked (\inlinesymbol\Tick) as \emph{bundled} are not including in
the source repository, but the build system includes support for downloading
tarballs with the source code and doing a local build. When enabled, bundled
dependencies will be automatically downloaded, built, and used, instead
instead of the versions provided by the system. In the case of using
\verb|libdward| bundled, it will be statically linked.
See~\nameref{sec:running-configure} for instructions for enabling bundled
libraries.

\begin{table}
    \begin{tabular}{ccp{0.4\textwidth}}
       	\toprule
	Distribution & Installation Command & Packages \\
	\midrule
	Debian, Ubuntu\footnote{Those systems do not provide Lua 5.3 packages
	at the time of writing, therefore usage of of the bundled version is
	recommended. See~\autoref{sec:running-configure} for instructions.} &
	    \verb|{apt-get install| &
	    \verb|libdwarf-dev| \verb|ninja-build| \\
	Arch Linux & \verb|pacman -S| & \verb|libdwarf| \verb|ninja| \verb|lua| \\
	\bottomrule
    \end{tabular}
    \caption{Dependency packages in popular GNU/Linux distributions.}
    \label{tab:distro-dependency-packages}
\end{table}

\autoref{tab:distro-dependency-packages} shows required packages as provided
by popular GNU/Linux distributions. Some versions of Debian (and derivatives
like Ubuntu) include only a static version of \verb|libdwarf| in the packages,
most likely not built as \gls{PIC}, which is a requirement.

\section{Project Structure}

The \Eris* source code

\begin{figure}[h]
    \centering
    \noindent\begin{minipage}{0.75\textwidth}
\dirtree{%
.1 \DtFolder{eris/}.
.2   \DtFolder{doc/} \DTcomment{Documentation and API reference}.
.2   \DtFolder{examples/}.
.3     *.lua \DTcomment{Module usage examples}.
.2   \DtFolder{tools/} \DTcomment{Build \& test utilities}.
.3     \DtFolder{ninja/} \DTcomment{Ninja build support files}.
.3     \DtFolder{make/} \DTcomment{GNU Make build support files}.
.2   \DtFolder{test/}.
.3     *.lua \DTcomment{Unit tests}.
.2   uthash.h \DTcomment{Copy of UT-hash}.
.2   eris-*.c \DTcomment{Module sources}.
.2   eris-*.h \DTcomment{Module sources}.
}
    \end{minipage}
    \caption{Source tree structure.}
\end{figure}


\section{Type Representation}

The \texttt{ErisTypeInfo} structure is used to represent type information.

\begin{listing}
    \centering
    \begin{minted}[autogobble]{c}
	typedef enum {
	    ERIS_TYPE_VOID,    /* void        */
	    ERIS_TYPE_BOOL,    /* _Bool       */
	    ERIS_TYPE_S8,      /* int8_t      */
	    ERIS_TYPE_U8,      /* uint8_t     */
	    ERIS_TYPE_S16,     /* int16_t     */
	    ERIS_TYPE_U16,     /* uint16_t    */
	    ERIS_TYPE_S32,     /* int32_t     */
	    ERIS_TYPE_U32,     /* uint32_t    */
	    ERIS_TYPE_S64,     /* int64_t     */
	    ERIS_TYPE_U64,     /* uint64_t    */
	    ERIS_TYPE_FLOAT,   /* float       */
	    ERIS_TYPE_DOUBLE,  /* double      */
	    ERIS_TYPE_TYPEDEF, /* typedef … T */
	    ERIS_TYPE_CONST,   /* const T     */
	    ERIS_TYPE_POINTER, /* T*          */
	    ERIS_TYPE_ARRAY,   /* T …[n]      */
	    ERIS_TYPE_STRUCT,  /* struct …    */
	    ERIS_TYPE_UNION,   /* union …     */
	    ERIS_TYPE_ENUM,    /* enum …      */
	} ErisType;
    \end{minted}
    \caption{\texttt{ErisType} enumeration.}
    \label{lst:ErisType}
\end{listing}

\begin{minted}{c}
struct _ErisTypeInfo {
    ErisType type;
    union {
        struct TI_base     ti_base;
        struct TI_pointer  ti_pointer;
        struct TI_typedef  ti_typedef;
        struct TI_const    ti_const;
        struct TI_array    ti_array;
        struct TI_compound ti_compound;
    };
};
typedef struct _ErisTypeInfo ErisTypeInfo;
\end{minted}


\section{Memory owners and life-cycle}

Problem: functions that allocate memory

\begin{minted}{c}
struct point {
	int x;
	int y;
};
\end{minted}

In Lua, we could create an instance like this:

\begin{minted}{lua}
local Geometry = eris.wrap("libgeometry.so")
-- Creates heavy userdata, the Lua GC handles freeing memory
local point = Geometry.point { x = 1, y = -1 }
\end{minted}

